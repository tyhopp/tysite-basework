[{"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"4jgiilbaovvs"}},"id":"programmatic-publishing-to-contentful","type":"Entry","createdAt":"2020-01-30T05:28:10.048Z","updatedAt":"2020-01-30T08:26:40.604Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment"}},"revision":8,"contentType":{"sys":{"type":"Link","linkType":"ContentType","id":"blogPost"}},"locale":"en-US"},"fields":{"title":"Programmatic publishing to Contentful","slug":"programmatic-publishing-to-contentful","date":"2020-01-29","shortDescription":"Leveraging Contentful in an automated publishing pipeline extends its use beyond expectation.","category":["JavaScript"],"body":"\n*This is note 5 of 5 in a series on [publishing automation](https://tyhopp.com/notes/publishing-automation).*\n\nThe world of [headless content management systems (CMS)](https://headlesscms.org)  and [Jamstack](https://jamstack.org) architecture is an exciting movement that puts content, not apps, back at the heart of the web. The programmer [Daniel Janus](http://blog.danieljanus.pl/2019/10/07/web-of-documents/) delineates this app/content divide clearly:\n\n> These days, the WWW is mostly a *Web of Applications*. An application is a broader concept: it can display text or images, but also lets you interact not just with itself, but with the world at large. And that’s all well and good, as long as you consciously intend these interactions to happen.\n\n> A document is safe. A book is safe: it will not explode in your hands, it will not magically alter its contents tomorrow, and if it happens to be illegal to possess, it will not call the authorities to denounce you. You can implicitly trust a document by virtue of it being one. An application, not so much.\n\nI’m a fan of this historical view of the web as a place to view content, or *documents*, via static websites. With this view as an ideal, the problem that CMS’ try to solve, despite often existing as web apps in and of themselves, is paramount: how to create, modify and organize these documents.\n\nThis last note in the series shows how we can keep content at the heart of our site's technical implementation *and* increase speed and convenience of delivery to the web. By leveraging a modern headless CMS like [Contentful](https://contentful.com), we can develop a custom publishing automation pipeline to make the place we *author* and *publish* one and the same.\n\n### Programmatic Contentful\n\nIn [the previous note in this series](https://tyhopp.com/notes/aws-lambda-functions-in-netlify), we built and deployed the [Lambda function from this site](https://github.com/tyhopp/tysite/tree/master/functions/bear-to-contentful), parsed the text of the note passed from Bear, and prepared to send the structured content to Contentful’s [Content Management API](https://www.contentful.com/developers/docs/references/content-management-api/). We then call our `createBlogPost` function which will create/update and publish our blog post to Contentful:\n\n```javascript\n/**\n * Creates/updates and publishes a Contentful entry.\n * @param {Object} payload The raw note text to parse\n */\nconst createBlogPost = async payload => {\n  try {\n    const blogPost = format(payload);\n    const { sys: { version } = {}} = await getEntry(blogPost);\n    const blogPostEntry = await createEntry({\n      payload: blogPost,\n      version: version ? version: 1\n    });\n    await publishEntry(blogPostEntry);\n    return {\n      statusCode: 200,\n      body: `Success, published version ${blogPostEntry.sys.version++} of “${blogPost.fields.title[‘en-US’]}”`\n    }\n  } catch(e) {\n    console.log(`Failed to create blog post. ${e}`);\n    return {\n      statusCode: 500,\n      body: “Internal Server Error”\n    }\n  }\n}\n```\n\nBreaking down this function:\n\n* We pass our parsed blog post object to `getEntry`, which [gets a single Contentful entry](https://www.contentful.com/developers/docs/references/content-management-api/#/reference/entries/entry/get-a-single-entry/console) and returns it. We then restructure the returns to expose the version of the entry, which we will use later to know whether we need to create a new entry or update an existing one.\n* Next, we call `createEntry` and pass it the blog post object and version, which [creates or updates a single Contentful entry](https://www.contentful.com/developers/docs/references/content-management-api/#/reference/entries/entry/create-update-an-entry/console).\n* Finally, we call `publishEntry`, which takes the newly created/updated blog post and publishes it, triggering a [webhook](https://www.contentful.com/developers/docs/concepts/webhooks/ ) that signals [Netlify](https://www.netlify.com) to rebuild the site with the new content included.\n\nBut before looking deeper into each of the calls to the Content Management API, we really should talk about [content modeling](https://www.contentful.com/r/knowledgebase/content-modelling-basics/).\n\n### Content modeling can make or break you\nWhen configuring any CMS for the first time, you’ll need to engage with the ritual that is content modeling. In other words, in order to create that blog post piece of content, the CMS needs to know what pieces of information or *fields* make up said blog post. In our case, I defined our blog post fields to be as flat as possible, with the name and type of field:\n\n```markdown\n|- title (short text)\n|- slug (short text)\n|- date (date & time)\n|- short description (long text)\n|- category (short text, list)\n|- body (long text)\n```\n\nSimple enough. But this is a revised state—the original structure looked more like this:\n\n```markdown\n|- title (short text)\n|- slug (short text)\n|- date (date & time)\n|- short description (long text)\n|- category (short text, list)\n|- content (container)\n   |- body (long text)\n```\n\nThe key difference is the last item. If we define our blog post content type to have a container filled with different individual blocks of content (text, images, maybe video in the future, etc.), then programmatic publishing is much less straightforward. With this nested structure, you must explicitly keep track of *links between content blocks*. This means we have to first create the most nested blocks, such as a text block, then create the container and link the text block to the container. This was what the first version of the function above looked like as a result:\n\n```javascript\n/**\n * Creates an individual entry in Contentful.\n * @param {Object} entry An individual entry\n * @param {string} entry.key The content type of the entry\n * @param {Object} entry.data The payload to send\n * @returns {Object} response The request response from the Content Management API.\n */\nconst createIndividualEntry = ({ key, data }) => fetch(`${base}/${createEntryPath}/${uuid()}`, {\n  method: ‘PUT’,\n  headers: headers(key),\n  body: JSON.stringify(data)\n})\n  .then(res => res.json());\n\n/**\n * Creates a series of individual entries in Contentful that are linked together.\n * Starts from the most nested entry and ends with the blog post itself.\n */\nconst createEntry = () => {\n\n  // First, create a text block\n  return createIndividualEntry(textEntry)\n    .then(({ sys: { id, version }}) => {\n      const blockText = { id, version };\n      containerEntry.data.fields.content[‘en-US’][0].sys.id = id; // Required to link to container\n      console.log(‘✅ Created a text block’);\n\n      // Then, create a container with content of text block\n      return createIndividualEntry(containerEntry)\n        .then(({ sys: { id, version }}) => {\n          const container = { id, version };\n          postEntry.data.fields.content[‘en-US’].sys.id = id; // Required to link to blog post\n          console.log(‘✅ Created a container’);\n\n        // Then, create a blog post\n        return createIndividualEntry(postEntry)\n          .then(({ sys: { id, version }}) => {\n            const blogPost = { id, version };\n            console.log(‘✅ Created a blog post’);\n\n            // Finally, return entry reference containing id and version\n            return [blockText, container, blogPost];\n          });\n        });\n      });\n    \n}\n```\n\nTo avoid this pain, I re-defined my blog post to be completely flat, enabling the function to make a single call to create and a single call to publish. If you’re starting from scratch for a simple project, I highly recommend you keep your content model *as flat as possible*.\n\n### Get, create and publish\nBack to our `createBlogPost` function above, let’s look at each of the three smaller functions it calls.\n\nFirst, `getEntry` to get the version of the blog post if it already exists:\n\n```javascript\n/**\n * Gets an individual entry in Contentful.\n * @returns {Object} response from the Content Management API\n */\nconst getEntry = payload => {\n  const id = payload.fields.slug[‘en-US’]; // Use unique slug as id\n  return fetch(`${base}/${path}/${id}`, {\n    method: ‘GET’,\n    headers\n  })\n    .then(res => {\n      try {\n        return res.json();\n      } catch(e) {\n        console.log(`Failed to parse get entry response.\\n${e}`);\n      }\n    });\n};\n```\n\nThen, `createEntry` using the version as a parameter:\n\n```javascript\n/**\n * Creates an individual entry in Contentful.\n * @param {Object} payload blog post payload to send\n * @returns {Object} response from the Content Management API\n */\nconst createEntry = ({ payload, version }) => {\n  const id = payload.fields.slug[‘en-US’]; // Use unique slug as id\n  return fetch(`${base}/${path}/${id}`, {\n    method: ‘PUT’,\n    headers: {\n      …headers,\n      ‘X-Contentful-Version’: version\n    },\n    body: JSON.stringify(payload)\n  })\n    .then(res => {\n      try {\n        return res.json();\n      } catch(e) {\n        console.log(`Failed to parse create entry response.\\n${e}`);\n      }\n    })\n    .then(data => {\n      if (data.sys.type === ‘Error’) {\n        console.log(`❌ Failed to create Contentul entry.\\n${JSON.stringify(data)}`);\n        return;\n      };\n      console.log(`✅ Created item ${id}`);\n      return data;\n    });\n}\n```\n\nFinally, publish the newly created/updated entry:\n\n```javascript\n/**\n * Publishes the blog post that was just created in Contentful.\n * @param {Object} entry entry object returned from Contentful\n * @param {Object} entry.sys system object returned from Contentful\n * @param {string} entry.sys.id id of the entry to publish\n * @param {string} entry.sys.version version of the entry to publish\n */\nconst publishEntry = ({ sys: { id, version }}) => {\n  return fetch(`${base}/${path}/${id}/published`, {\n    method: ‘PUT’,\n    headers: {\n      …headers,\n      ‘X-Contentful-Version’: version\n    }\n  })\n    .then(res => {\n      try {\n        return res.json();\n      } catch(e) {\n        console.log(`Failed to parse publish entry response.\\n${e}`);\n      }\n    })\n    .then(data => {\n      if (data.sys.type === ‘Error’) {\n        console.log(`❌ Failed to publish Contentful entry. ${data.message}`);\n        return;\n      };\n      console.log(`✅ Published item ${id}`);\n      return data;\n  });\n}\n```\n\nAnd once more, put all together in the `createBlogPost` function:\n\n```javascript\n/**\n * Creates/updates and publishes a Contentful entry.\n * @param {Object} payload The raw note text to parse\n */\nconst createBlogPost = async payload => {\n  try {\n    const blogPost = format(payload);\n    const { sys: { version } = {}} = await getEntry(blogPost);\n    const blogPostEntry = await createEntry({\n      payload: blogPost,\n      version: version ? version: 1\n    });\n    await publishEntry(blogPostEntry);\n    return {\n      statusCode: 200,\n      body: `Success, published version ${blogPostEntry.sys.version++} of “${blogPost.fields.title[‘en-US’]}”`\n    }\n  } catch(e) {\n    console.log(`Failed to create blog post. ${e}`);\n    return {\n      statusCode: 500,\n      body: “Internal Server Error”\n    }\n  }\n}\n```\n\nAnd there we have it! Zooming out to the entire automated publishing pipeline:\n\n* We write our note in Bear\n* Call this function from Scriptable in our share sheet\n* This function creates/updates and publishes our note to Contentful\n* A Contentful webhook notifies Netlify, and Netlify rebuilds the site with the new content\n\nAs a direct result of this pipeline, I can say that my focus has improved and rate of publishing has increased at least 3 fold. The ability to edit on the fly on my phone and publish updates instantly enables a continuous flow state while commuting and better writing overall. Suffice to say, I enjoy writing again.\n\nIf you’ve read through this entire series, thank you, it’s been a pleasure. Do let me know if you implement something similar!\n\nCheers 🍻\n\nPrevious articles in this series:\n* [Publishing automation](https://tyhopp.com/notes/publishing-automation)\n* [Bear as an authoring tool for the web](https://tyhopp.com/notes/bear-as-an-authoring-tool)\n* [JavaScript in iOS with Scriptable](https://tyhopp.com/notes/js-in-ios-scriptable)\n* [AWS Lambda functions via Netlify](https://tyhopp.com/notes/aws-lambda-functions-in-netlify)\n\n"}},{"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"4jgiilbaovvs"}},"id":"aws-api-gateway-gotchas","type":"Entry","createdAt":"2019-12-16T05:46:28.345Z","updatedAt":"2020-01-30T08:12:33.358Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment"}},"revision":10,"contentType":{"sys":{"type":"Link","linkType":"ContentType","id":"blogPost"}},"locale":"en-US"},"fields":{"title":"AWS API Gateway gotchas","slug":"aws-api-gateway-gotchas","date":"2019-12-16","shortDescription":"A running list of things that you might encounter working with AWS API Gateway.","category":["AWS"],"body":"\nI enjoy this era of accessible and affordable cloud services as much as the next developer. But where [gotchas](https://en.m.wikipedia.org/wiki/Gotcha_(programming)) exist, they should be noted, for my own reference at least. This is a running list of things I've encountered working with [AWS' API Gateway](https://aws.amazon.com/api-gateway/).\n\n### When methods on a resource don't exist, the response is 403\n\nIn other words if you're making a POST to an endpoint that only has PUT, API Gateway will tell you **you don't have credentials** and might even give you a CORS error in your console. This will send you down the wrong rabbit hole thinking you misconfigured something in your method or integration response.\n\nSpecifically, a request with a method that doesn't exist on a resource returns a 403 Forbidden error when it should instead return a 405 Method Not Allowed error. A [post on the AWS forms](https://forums.aws.amazon.com/thread.jspa?threadID=216684) from 2015 addresses the issue and someone from AWS responded saying they would add it to the backlog in 2016, but I'm still getting this issue in 2019. The [W3 spec](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.6) definition for a 405 error matches this case exactly:\n\n> 10.4.6 405 Method Not Allowed:\n> The method specified in the Request-Line is not allowed for the resource identified by the Request-URI. The response MUST include an Allow header containing a list of valid methods for the requested resource.\n\n### Header names are processed as case sensitive\n\nIn AWS' [list of known issues](https://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-known-issues.html), they say:\n\n> API Gateway enacts the following restrictions and limitations when handling methods with either Lambda integration or HTTP integration: Header names and query parameters are processed in a case-sensitive way.\n\nBut according to [the W3 spec](https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2), header names should be case insensitive:\n\n> Each header field consists of a name followed by a colon (\":\") and the field value. Field names are case-insensitive.\n\nIn the scenario I encountered this issue, this quirk was compounded by the fact that [the fetch polyfill by GitHub](https://github.com/github/fetch) that so many projects use (including ours) [lowercases header names](https://github.com/github/fetch/blob/master/fetch.js#L50). This is the polyfill recommended in [Google's web developer documentation](https://developers.google.com/web/updates/2015/03/introduction-to-fetch) and [by MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API), the two most authoritative sources of technical documentation for the web aside from the official W3 spec. So if your backend services or your configured request headers in API gateway use the standard capitalization for header names (e.g. Content-Type), you're in for a world of hurt.\n"}},{"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"4jgiilbaovvs"}},"id":"aws-lambda-functions-in-netlify","type":"Entry","createdAt":"2020-01-16T02:03:23.871Z","updatedAt":"2020-01-30T08:12:15.738Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment"}},"revision":6,"contentType":{"sys":{"type":"Link","linkType":"ContentType","id":"blogPost"}},"locale":"en-US"},"fields":{"title":"AWS Lambda functions via Netlify","slug":"aws-lambda-functions-in-netlify","date":"2020-01-15","shortDescription":"Netlify takes the headache out of hosting and deploying a cloud function from your domain too.","category":["AWS","JavaScript"],"body":"\n*This is note 4 of 5 in a series on [publishing automation](https://tyhopp.com/notes/publishing-automation).*\n\nIf you’re a frontend developer in 2020, the [serverless](https://serverless.css-tricks.com) movement has given you agency that you’ve never had before: writing server-side code without all the nuance and pain of infrastructure configuration. [Netlify](https://www.netlify.com), a platform for hosting and continuously deploying your site without touching tools like [Jenkins](https://jenkins.io) or [Bamboo](https://www.atlassian.com/software/bamboo), takes the serverless idea and pushes the bill even further with [Netlify Functions](https://www.netlify.com/products/functions/). Now, creating a call-able REST API that runs an [AWS Lambda function](https://aws.amazon.com/lambda/features/) is as simple as creating a directory in our repo, flipping a switch in Netlify and writing the code.\n\nTo achieve the dream of [using Bear as an authoring tool for the web](https://tyhopp.com/notes/bear-as-an-authoring-tool), I decided to leverage the power of Netlify functions to write a service callable via [Scriptable](https://tyhopp.com/notes/js-in-ios-scriptable) in iOS. The complete flow shapes up like this:\n\n* Write a note in Bear\n* Click 'Share' from the note\n* Click 'Run Script' in Scriptable to run some JavaScript\n* The script makes a PUT request to our Netlify function, sending the note's content\n* Our function parses the note content and makes requests to [Contentful](https://contentful.com), sending the note there, creating and publishing content blocks\n* Contentful triggers Netlify to re-deploy the website when the new note is published\n* Netlify deploys the site and the note is viewable from the website\n\n### Define the scope of our function\nBefore hacking away, it's helpful to define exactly what the function should achieve:\n\n* Define a REST endpoint with a PUT method\n* Expose the resource on this domain, https://tyhopp.com\n* Require a special header, in our case `bear-to-contentful`, with a secret access key so we have permission to create objects in Contentful\n* Parse the raw markdown note payload and format into a structured object that we can send to the [Contentful Content Management API](https://www.contentful.com/developers/docs/references/content-management-api/)\n* Call the Contentful API to create the note in Contentful\n* Call the Contentful API to publish the note in Contentful\n* Return a success or error response to the caller, in our case Scriptable\n\nWith this spec, let's dive deeper into the code required to pull it off.\n\n### But first, some setup\nThe whole point of using Netlify over the cloud platforms like [AWS](https://aws.amazon.com), [Azure](https://azure.microsoft.com/en-us/) and [GCP](https://cloud.google.com) directly is to avoid all the required steps before you can actually write your code: setting up a billing account, provisioning permissions, configuring API gateways, etc. The luxury of Netlify Functions is we don’t even need an account, and the same generous free tier you get on all the platforms (~125k requests and 100 hours of run time) applies here too. Still, you do have to do a couple steps of setup:\n\n- In your Netlify web interface, go to Settings > Functions and [enter the path to your functions directory](https://docs.netlify.com/functions/configure-and-deploy/#configure-the-functions-folder) in your site, in my case `./functions`.\n- Install [netlify-dev](https://github.com/netlify/cli/blob/master/docs/netlify-dev.md#netlify-functions), the tool they created to enable us to test our functions locally before deploying. In any sane workflow, this is a necessary step. Follow the docs to get up and running.\n\n### Write the code\n*To see the finished function currently in production, check it out on [GitHub](https://github.com/tyhopp/tysite/tree/master/functions/bear-to-contentful) - I open sourced this site recently!* 🍻\n\nNow that we have our path declared and our workflow setup, we can commence with the actual programming. A very useful set of examples can be found [on this playground site](https://functions-playground.netlify.com), progressing from hello world to writing a Slack integration. Copy and paste some code to get a feel for it.\n\nFor our case, the root function looks like this:\n\n```javascript\nconst { createBlogPost } = require(‘./src/actions/create’);\nconst { BEAR_TO_CONTENTFUL } = process.env;\n\n/**\n * A lambda function to create/update and publish blog posts in Contentful.\n */\nexports.handler = async event => {\n\n  // Ensure credentials are passed\n  if (!event.headers[‘bear-to-contentful’] || (event.headers[‘bear-to-contentful’] !== BEAR_TO_CONTENTFUL)) {\n    return {\n      statusCode: 401,\n      body: “Invalid Credentials”\n    };\n  }\n\n  // Parse method and take appropriate action\n  switch(event.httpMethod) {\n    case ‘POST’:\n    case ‘PUT’:\n      return createBlogPost(JSON.parse(event.body));\n    default:\n      return {\n        statusCode: 405,\n        body: “Method Not Allowed”\n      };\n  }\n};\n```\n\nWe export a single nameless, asynchronous function and pass in the `event` parameter, which contains all the properties we need to parse the request: `headers`, `body` and `httpMethod`. In this function, we only need two checks:\n\n* Make sure the `bear-to-contentful` header exists and the value matches our [environment variable defined in Netlify](https://docs.netlify.com/configure-builds/environment-variables/) (which we got from Contentful, to be covered in greater detail in the next note).\n* Make sure the `httpMethod` is `POST` or `PUT`, since we only want to focus on creating and updating blog posts for now. From [Scriptable we will call PUT](https://tyhopp.com/notes/js-in-ios-scriptable), because `PUT` works in both create and update cases while `POST` works only for creation.\n\nIf both conditions are met, we send the body into our `createBlogPost` function and try to parse, create and publish to Contentful. The key is that if at any point in the function we want to throw an error or return a successful response, we do that by returning an object with a `statusCode` and `body`.\n\n### Define an interface\nBefore diving into the `createBlogPost` function, we have to consider how our script will parse the things that our Contentful blog post content model requires (more on [content modeling](https://www.contentful.com/r/knowledgebase/content-modelling-basics/) in the next post). Even if you’re not using Contentful for your cases, your CMS will still need to differentiate between things like your `title`, `description` and `body`, making this step generally relevant. In my case, I need to parse out these pieces:\n\n* title\n* slug\n* date\n* short description\n* category\n* body\n\nWith that in mind, I created a standard template that all blog posts I write in Bear will use. In doing this, we can create a predictable request body that is more easily parsable in our `createBlogPost` function. Here’s what it looks like in markdown:\n\n```markdown\n# Title\nslug: my-slug\ndate: YYYY-MM-DD\ndescription: A description\ncategories: First, Second\n—-—\nThe body of my note\n```\n\n### Parse the note\nIn our cloud function, the [parse and format utility functions](https://github.com/tyhopp/tysite/blob/master/functions/bear-to-contentful/src/utils/format.js) do the regex parsing to break down the markdown above into an object:\n\n```javascript\n/**\n * Parses the input markdown and returns as an object.\n * @param {string} text the raw markdown to process\n */\nconst parse = text => {\n    // Trim everything before first #\n    const trimmedText = text.substring(/(.*?)#/s.exec(text)[1].length);\n\n    // Parse categories\n    const parsedCategories = /categories: (.*?)\\n/.exec(trimmedText)[1];\n    const categories = /,/.test(parsedCategories)\n      ? parsedCategories.split(‘, ‘)\n      : [parsedCategories];\n    \n    // Parse all other values\n    return {\n      title: /# (.*?)\\n/.exec(trimmedText)[1],\n      slug: /slug: (.*?)\\n/.exec(trimmedText)[1],\n      date: /date: (.*?)\\n/.exec(trimmedText)[1],\n      description: /description: (.*?)\\n/.exec(trimmedText)[1],\n      categories,\n      body: trimmedText.substring(/#(.*)—/s.exec(trimmedText)[1].length + 4)\n    };\n}\n\n/**\n * Formats a flat object into desired Contentful payload.\n * @param {string} text the raw markdown to process\n */\nconst format = text => {\n  const { title, slug, date, description, categories, body } = parse(text);\n  console.log(`\\n\n  Note details:\n  —\n  title: ${title}\n  slug: ${slug}\n  date: ${date}\n  description: ${description}\n  categories: ${categories}\n  body: ${body.substring(1, 60)}…\n  —\n  `);\n  return {\n    ‘fields’: {\n      ‘title’: { ‘en-US’: title },\n      ‘slug’: { ‘en-US’: slug },\n      ‘date’: { ‘en-US’: date },\n      ‘shortDescription’: { ‘en-US’: description },\n      ‘category’: { ‘en-US’: categories },\n      ‘body’: { ‘en-US’: body }\n    }\n  }\n};\n\nmodule.exports = {\n  format\n}\n```\n\nThere are dozens of ways we could write the regex, and I’m sure what’s written above isn’t the most efficient, but it works for our purposes. Once the parsing is done, we can move on to the tricky business of [forming the fetch requests to the Contentful Content Management APIs](https://github.com/tyhopp/tysite/blob/master/functions/bear-to-contentful/src/actions/create.js), which will be the subject of the last article in this series:\n\n- [Programmatic publishing to Contentful](https://tyhopp.com/notes/programmatic-publishing-to-contentful)\n\nPrevious articles in this series:\n* [Publishing automation](https://tyhopp.com/notes/publishing-automation)\n* [Bear as an authoring tool for the web](https://tyhopp.com/notes/bear-as-an-authoring-tool)\n* [JavaScript in iOS with Scriptable](https://tyhopp.com/notes/js-in-ios-scriptable)\n"}},{"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"4jgiilbaovvs"}},"id":"js-in-ios-scriptable","type":"Entry","createdAt":"2020-01-13T01:35:38.696Z","updatedAt":"2020-01-30T07:48:16.092Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment"}},"revision":10,"contentType":{"sys":{"type":"Link","linkType":"ContentType","id":"blogPost"}},"locale":"en-US"},"fields":{"title":"JavaScript in iOS with Scriptable","slug":"js-in-ios-scriptable","date":"2020-01-13","shortDescription":"Running any code at all in iOS is a feat. But being able to run JavaScript from my iPhone to make a network request on command, that’s a superpower.","category":["JavaScript"],"body":"\n*This is note 3 of 5 in a series on [publishing automation](https://tyhopp.com/notes/publishing-automation).*\n\nWhen [Apple acquired Workflow](https://www.theverge.com/2017/3/22/15030462/apple-acquires-workflow-iphone-utility), rebranded it as [‎Shortcuts](https://apps.apple.com/sg/app/shortcuts/id1462947752) and then shipped it on every home screen that downloaded iOS 13, iOS suddenly became a lot more flexible. Apple’s first party apps and major third party apps alike shipped with built in shortcuts like “Send a message to Mom” and “Create an event with Zach”. [Bear](https://bear.app), my favorite note taking app and target of desire to [use as an authoring tool for this website](https://tyhopp.com/notes/bear-as-an-authoring-tool ), also shipped with a host of neat shortcuts. To name a few:\n\n* Create Bear Note from URL\n* Search in Bear\n* Create Bear Note\n* Open Bear Note\n* Get Contents of Bear Note\n\nAbsent however from the list was something that could be used to extend Bear as a publishing tool. Something like “Post Bear Note to a URL,” albeit unlikely, would have made that goal immediately attainable. Instead, it became clear that despite this lengthy introduction, Workflow wasn’t the tool for the problem we're solving: make a custom network request in iOS. If possible, then we could write a cloud function, deploy it on this website, handle the payload and then post it to our CMS of choice ([Contentful](https://www.contentful.com) in my case). The CMS would then trigger a webhook in [Netlify](https://www.netlify.com), automatically deploying a new version of this site.\n\n### Running code in iOS\nTo achieve such a thing, there are a few options. The most popular one, and the only one that shipped with shortcuts available by default, is [Pythonista for iOS](http://omz-software.com/pythonista/), a fully-fledged Python IDE for iOS. The only thing is, I prefer to write JavaScript, which I use daily at work. Pythonista would be the perfect option for, well, *Pythonistas*, given its years of continuous support and consistently high quality updates, but for JS developers there's another option: [Scriptable](https://scriptable.app).\n\n### Scriptable as glue for automation\nScriptable is perfect for our case. Written by [Simon B. Støvring](https://twitter.com/simonbs) and using Apple’s [JavaScriptCore](https://developer.apple.com/documentation/javascriptcore), the app does a fantastic job of wrapping iOS APIs in JavaScript and allowing them to be used just like we might use the web APIs native to browsers. It’s a weird feeling at first because the APIs are domain-specific, but after a bit of tinkering I etched out this script:\n\n```javascript\n// This script publishes a note from Bear to https://tyhopp.com\n\n// Get shared note text\nlet note = args.plainTexts[0];\n\n// Make POST request to publish note\nlet endpoint = 'https://tyhopp.com/.netlify/functions/bear-to-contentful';\nlet request = new Request(endpoint);\nrequest.headers = {\n// Secret Contentful access key\n'bear-to-contentful': ‘XXXXXXXXXX',\n'Content-Type': 'application/json'\n};\nrequest.body = JSON.stringify(note);\nrequest.method = 'PUT';\nlet response = await request.loadString();\n\n// Show response message\nlet alert = new Alert()\nalert.title = response\nalert.addCancelAction(\"OK\")\nawait alert.presentAlert()\n\nScript.complete();\n```\n\nThe documentation for the different classes is most readily available within the Scritable app, so if you’re interested to do something similar do be sure to [give the app a whirl](https://apps.apple.com/us/app/scriptable/id1405459188?ign-mpt=uo%3D4). For the script above, here are the key things to note:\n\n * When we’re on a Bear note and click ‘Share’, we can then select ’Run Script’ with Scriptable.\n * This passes the content of the shared Bear note to Scriptable, which can be accessed through `args.plainTexts` .\n * Once we have the content of the Bear note in Scriptable, we create a new `Request` and fill the required `headers`, `body` and `method` properties on the request.\n * We then wait for the response, and show a message in an `Alert` with whatever our API returns.\n\nAnd done! We now can make a network request with the content of our Bear note. The next step is the most code-heavy and arguably most interesting from a technical perspective: writing an AWS Lambda function via Netlify for us to call from Scriptable. In the next two articles I’ll cover that process exactly:\n\n- [AWS Lambda functions via Netlify](https://tyhopp.com/notes/aws-lambda-functions-in-netlify)\n- [Programmatic publishing to Contentful](https://tyhopp.com/notes/programmatic-publishing-to-contentful)\n\nPrevious articles in this series:\n* [Publishing automation](https://tyhopp.com/notes/publishing-automation)\n* [Bear as an authoring tool for the web](https://tyhopp.com/notes/bear-as-an-authoring-tool)\n\n\n"}},{"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"4jgiilbaovvs"}},"id":"bear-as-an-authoring-tool","type":"Entry","createdAt":"2020-01-12T04:59:02.846Z","updatedAt":"2020-01-30T07:25:46.686Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment"}},"revision":15,"contentType":{"sys":{"type":"Link","linkType":"ContentType","id":"blogPost"}},"locale":"en-US"},"fields":{"title":"Bear as an authoring tool for the web","slug":"bear-as-an-authoring-tool","date":"2020-01-12","shortDescription":"One of the greatest note taking apps is held back by the very reason for its greatness: a limited, focused feature set. Here’s how I extend it to be my authoring tool for this website.","category":["Misc"],"body":"*This is note 2 of 5 in a series on [publishing automation](https://tyhopp.com/notes/publishing-automation).*\n\n![bear-to-contentful-without-dither](//images.ctfassets.net/4jgiilbaovvs/6Rzh3yy020uEAyC6Lq2W4W/b8640626955a9687316a53d2b046d99c/bear-to-contentful-without-dither.gif)\n\n*Above - Publishing from Bear to this website. Dreams do come true* ❤️\n\n[Bear](https://bear.app) is hands down my favorite note taking app. Its apps are iOS native (not [Electron](https://electronjs.org) or [React Native](https://facebook.github.io/react-native/) apps slinging JavaScript), and as a result achieve a level of feel-good performance on par with Apple’s first party apps. Even more importantly, it uses the user’s own iCloud storage as a backend so Shiny Frog, the people that build Bear, never see any user data — period. Sure it’s an Apple-only product, but in a world awash with bad hybrid apps and malicious practices around user data, Bear is simple, beautiful and safe.\n\nTo boot, I and a lot of other people are most productive when writing in Bear. So naturally, wouldn’t it be great if we could use Bear to publish to other platforms, like the website you’re reading right now? I think yes, but there are obstacles:\n\n### There are no external publishing APIs\nBear ships on iOS, macOS and watchOS — not on Android or Windows, but a web app is forthcoming. The team is [very clear about their priorities](https://bear.app/faq/What%20about%20Bear%20for%20web,%20Android,%20or%20Windows/), and adding integrations to Bear isn’t one of them. However, this focus is clearly why Bear is so great. Thus, there’s no officially supported way to use Bear as an authoring tool for other platforms. Unless of course you count [‎WordPress for iOS](https://apps.apple.com/us/app/wordpress/id335703880), which [recently added functionality to publish from Bear](https://blog.bear.app/2019/05/introducing-a-new-way-to-publish-bear-notes-to-wordpress-on-ipad-and-iphone/) and only works if you’re using WordPress to start with. More info on that [here](https://bear.app/faq/How%20to%20blog%20with%20Bear%20on%20iPad%20and%20iPhone/).\n\n### It’s really hard to integrate apps on Apple platforms\n[App sandboxing](https://developer.apple.com/app-sandboxing/) adds a level of safety to the Apple ecosystem, but it also makes it much more difficult for apps to integrate with one another. That means if Bear doesn’t ship with functionality to publish to another platform, good luck trying to pull that off.  It does however support the [x-callback-url](http://x-callback-url.com) protocol and [clearly documents the interfaces](https://bear.app/faq/X-callback-url%20Scheme%20documentation/), but while this is very nice compared to other native iOS/macOS apps, it’s still much less accessible than having an actual REST API to call.\n\n### A solution\nUntil Shiny Frog ships a way to build off of Bear as an authoring tool, the best way to make it a reality to is build this pipeline yourself. In the next few articles I’ll talk in greater depth about how I did just that:\n\n- [JavaScript in iOS with Scriptable](https://tyhopp.com/notes/js-in-ios-scriptable)\n- [AWS Lambda functions via Netlify](https://tyhopp.com/notes/aws-lambda-functions-in-netlify)\n- [Programmatic publishing to Contentful](https://tyhopp.com/notes/programmatic-publishing-to-contentful)\n\nPrevious articles in this series:\n* [Publishing automation](https://tyhopp.com/notes/publishing-automation)\n"}},{"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"4jgiilbaovvs"}},"id":"publishing-automation","type":"Entry","createdAt":"2019-12-15T16:06:56.670Z","updatedAt":"2020-01-30T07:24:20.996Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment"}},"revision":13,"contentType":{"sys":{"type":"Link","linkType":"ContentType","id":"blogPost"}},"locale":"en-US"},"fields":{"title":"Publishing automation","slug":"publishing-automation","date":"2019-12-14","shortDescription":"Why I built an automated publishing workflow tailored to my writing process.","category":["Misc"],"body":"\n*This is the first note in a series on publishing automation.*\n\nI think there’s a productivity gap in how we write articles and publish to the web. The tools that we feel the most productive writing with are usually not the same tools that we use to effectively manage and publish content. Some examples of this:\n\n* You have a Wordpress or Squarespace blog and use the in-browser editor as your main writing tool. You get distracted because you’re in a browser and this editor is just one interesting tab of many. Distraction is just a Google search away. The article is never published.\n* You have a Content Management System (CMS) that is “headless,” or completely separate from your website. You write with their in-browser editor and face problem #1. In addition, the fiddly task of managing blocks of content and the links between them slows down your productivity further. The article is published, albeit with much more time and effort than you hoped.\n* You use either of the above systems, but you also use your favorite writing tools locally to hash out your article. Then, you upload it to wherever it is you publish from. The main act of writing is efficient, but the disconnect and context switch is not. Time used bridging this gap is time lost writing.\n\nThese scenarios have a number of assumptions, but put side by side, a pattern emerges. If we could write where we’re most productive and publish from there, I think we’d have the greatest shot at keeping the crucial momentum of writing going.\n\n### The project\nWhat if the tools we use could talk to each other seamlessly? Over the last few months, I tinkered on an automated workflow tailored to the way I write, manage and publish notes on this site. In the next few articles I’ll talk in greater depth about each step of the process:\n\n- [Bear as an authoring tool for the web](https://tyhopp.com/notes/bear-as-an-authoring-tool)\n- [JavaScript in iOS with Scriptable](https://tyhopp.com/notes/js-in-ios-scriptable)\n- [AWS Lambda functions via Netlify](https://tyhopp.com/notes/aws-lambda-functions-in-netlify)\n- [Programmatic publishing to Contentful](https://tyhopp.com/notes/programmatic-publishing-to-contentful)\n"}},{"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"4jgiilbaovvs"}},"id":"ffmpeg-crosshatch","type":"Entry","createdAt":"2020-01-12T08:09:04.369Z","updatedAt":"2020-01-12T08:12:53.490Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment"}},"revision":2,"contentType":{"sys":{"type":"Link","linkType":"ContentType","id":"blogPost"}},"locale":"en-US"},"fields":{"title":"Removing crosshatch when creating a GIF in ffmpeg","slug":"ffmpeg-crosshatch","date":"2020-01-12","shortDescription":"If you want to do video manipulation, ffmpeg will serve you well. One thing always bothered me though: the crosshatch pattern imprinted on GIFs. Here’s how to remove it.","category":["Misc"],"body":"\nIf you’re a human that doesn’t want to download a whole new application just to do a bit of video manipulation or make a GIF, stop what you’re doing and check out [ffmpeg](https://ffmpeg.org). It’s a command-line tool you can use to do all sorts of things, but what I most often end up doing is converting a screen recording to a GIF. There are dozens of articles around the web on how to do this, but I wanted to note the command I use here for my own quick reference. I avoid creating a script with variables and instead prefer to keep it as copy and paste-able as possible.\n\n*Keep in mind this post covers less than 0.1% of what ffmpeg can do — it’s an incredible library that most of us will never fully appreciate.*\n\n### MP4 to GIF, with defaults\n`ffmpeg -i my-video.mp4 my-gif.gif`\n\nThis is how to create a GIF with zero manipulation. The problem is, if you turn up the brightness on your display and look closely at the GIF below, there’s a visible crosshatch pattern overlay that wasn’t in the original video:\n\n![bear-to-contentful-default-short](//images.ctfassets.net/4jgiilbaovvs/77JfKa3D527TVycq5swVab/53e9eeee7b0540d0e726a4fc7387f1a7/bear-to-contentful-default-short.gif)\n\nTo remove this, you need to do some fancy manipulation.\n\n### MP4 to GIF, without dithering\nThe reason why the crosshatch exists is something called [dither](https://en.wikipedia.org/wiki/Dither):\n\n> **Dither** is an intentionally applied form of  [noise](https://en.wikipedia.org/wiki/Image_noise)  used to randomize  [quantization error](https://en.wikipedia.org/wiki/Quantization_error) , preventing large-scale patterns such as  [color banding](https://en.wikipedia.org/wiki/Color_banding)  in images.\n\nFor our case, all we need to understand is that ffmpeg uses dithering algorithms to avoid visual errors and make the media we create more predictable.\n\nTo remove it, ffmpeg has these really neat features called [palettegen](https://ffmpeg.org/ffmpeg-filters.html#palettegen-1) and [paletteuse](https://ffmpeg.org/ffmpeg-filters.html#paletteuse), which allow you to create a color palette of 256 pixels from your video, define a dithering algorithm, and use it when creating your GIF. Here’s how we do that in one command:\n\n`ffmpeg -i my-video.mp4 -vf palettegen palette.png && ffmpeg -i my-video.mp4 -i palette.png -filter_complex “paletteuse=dither=none” my-gif.gif`\n\n![bear-to-contentful-without-dither-short](//images.ctfassets.net/4jgiilbaovvs/4Y4v5nI3eJ9S1stcXJxWFI/d6c023eb969af9b15d90ad926052d1f2/bear-to-contentful-without-dither-short.gif)\n\nIf you look closely again, you can see the crosshatch is gone!\n\nNote this command actually contains two commands that you can run separately:\n* `ffmpeg -i my-video.mp4 -vf palettegen palette.png` to create a color palette from your MP4, and\n* `ffmpeg -i my-video.mp4 -i palette.png -filter_complex “paletteuse=dither=none” my-gif.gif` to use your color palette and a few other filters to make a GIF.\n\n### MP4 to GIF, with many more filters\nFinally, I want to reduce the file size, resize the GIF, and crop the resized GIF too. With the `-filter_complex` flag, we can add as many filters as we want with comma-separation:\n\n`ffmpeg -i my-video.mp4 -vf palettegen palette.png && ffmpeg -i my-video.mp4 -i palette.png -filter_complex “fps=15, scale=320:-1, crop=in_w:in_h-18:0:18, paletteuse=dither=none” my-gif.gif`\n\nThe added filters include:\n* `fps=15` to set the frames-per-second to 15, effectively reducing the file size\n* `scale=320:-1` to set the width to 320 pixels and determine the height based on the original aspect ratio\n* `crop=in_w:in_h-18:0:18` to crop 18 pixels from the top of the frame. This filter breaks down like this: `crop=in_w:in_h:w:h`, where:\n\t* `in_w` is the input file’s width,\n\t* `in-h` is the input file’s height,\n\t* `w` is the pixel to crop from on the x axis, and\n\t* `h` is the pixel to crop from on the y axis\n\nAnd there we have it! Copy and paste away, future self.\n"}},{"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"4jgiilbaovvs"}},"id":"responsive-svg","type":"Entry","createdAt":"2019-12-15T14:19:39.215Z","updatedAt":"2019-12-15T16:10:26.430Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment"}},"revision":6,"contentType":{"sys":{"type":"Link","linkType":"ContentType","id":"blogPost"}},"locale":"en-US"},"fields":{"title":"Responsive SVG backgrounds","slug":"responsive-svg","date":"2018-11-27","shortDescription":"How to change the SVG viewBox attribute given different screen sizes.","category":["JavaScript"],"body":"\nSVG is by far my favorite image format for its small size and ability to be manipulated dynamically via JavaScript. However, it can be tricky to implement in some cases. One such case I recently came across is how to resize the SVG `viewBox` as the viewport resizes.\n\nI'm by no means an expert on working with SVG, but I did discover one solution to this problem: using the `javascript^window.matchMedia()` web API:\n\n```javascript\n// Grab SVG element\nlet bg = document.getElementById('bg-mbl')\n\n// Media query event handler\nif (matchMedia) {\n\tlet mqls = [ // Array of media queries\n\t\twindow.matchMedia(\"(min-width: 400px) and (max-width: 600px)\"),\n\t\twindow.matchMedia(\"(min-width: 600px) and (max-width: 800px)\"),\n\t\twindow.matchMedia(\"(min-width: 800px) and (max-width: 1000px)\")\n\t]\n\n\tfor (i=0; i < mqls.length; i++) { // Loop though media queries\n\t\tmqls[i].addListener(widthChange) // Listen for queries\n\t\twidthChange(mqls[i]) // Call handler func at runtime\n\t}\n}\n\n// Media query change\nfunction widthChange(mql) {\n\tif (mqls[0].matches) { \n\t\tbg.setAttribute(\"viewBox\", \"0 150 375 580\")\n\t}\n\telse if (mqls[1].matches) {\n\t\tbg.setAttribute(\"viewBox\", \"0 300 375 580\")\n\t}\n\telse if (mqls[2].matches) {\n\t\tbg.setAttribute(\"viewBox\", \"0 400 375 580\")\n\t}\n\telse {\n\t\t// Set default\n\t\tbg.setAttribute(\"viewBox\", \"0 0 375 580\")\n\t}\n}\n```\n\nThe `matchMedia` API lets you pass a media query string, such as `css^min-width: 400px`, and will return a new `MediaQueryList`, which is a fancy object that helps manage when the media query state changes. In our case, we're querying for viewport width, so as the screen width changes and one of the media query cases becomes true, we reset the size of the SVG `viewBox` to our liking. According to [MDN](https://developer.mozilla.org/en-US/docs/Web/API/MediaQueryList):\n\n> MediaQueryList makes it possible to observe a document to detect when its media queries change, instead of polling the values periodically, and allows you to programmatically make changes to a document based on media query status.\n\nHappy querying!\n"}},{"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"4jgiilbaovvs"}},"id":"list-in-swift-ui","type":"Entry","createdAt":"2019-12-15T16:06:38.187Z","updatedAt":"2019-12-15T16:06:38.187Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment"}},"revision":1,"contentType":{"sys":{"type":"Link","linkType":"ContentType","id":"blogPost"}},"locale":"en-US"},"fields":{"title":"JS to Swift - Prototyping lists with SwiftUI","slug":"list-in-swift-ui","date":"2019-07-04","shortDescription":"Build a list in JavaScript, try to apply that method in Swift, realize it doesn't work, and find out how to do it properly in Swift!","category":["Swift","JavaScript"],"body":"\nSo you want to build a list with Apple's new declarative UI framework. Maybe you're used to building for the web like I am, and you think, \"Let's mock up a data structure and iterate over it to make a list.\" Pretty straightforward, or so you thought. In JavaScript, you might do something like this:\n\n```javascript\n// Mock data structure\nconst racers = [\n\t{\n\t\tid: 1,\n\t\tname: 'Valentino Rossi',\n\t\tteam: 'Yamaha'\n\t},\n\t{\n\t\tid: 2,\n\t\tname: 'Marc Márquez',\n\t\tteam: 'Repsol Honda'\n\t},\n];\n\n// In React\n<ul>\n{racers && racers.map(racer => (\n\t<li key={racer.id}>{racer.name} rides with {racer.team}</li>\n))};\n</ul>\n\n// In ES6\nconst list = document.querySelector('ul');\nracers.map(racer => {\n\tconst item = document.createElement('li');\n\titem.setAttribute('id', racer.id);\n\titem.textContent = `${racer.name} rides with ${racer.team}`;\n\tlist.appendChild(item);\n});\n```\n\nI thought I could do the same thing with SwiftUI. Define an array of dictionaries and iterate over them using something like SwiftUI's `ForEach` or `List` views. In UIKit, `List` would be roughly equal to `UITableView`, and from my experience with `UITableView`, the table wants everything to be set up in a very particular fashion. So approaching cautiously, will  `List` require us to do some extra stuff, or can we just chuck some data in and the world will be well and good? Turns out, there's a bit more setup. This won't work:\n\n```swift\nimport SwiftUI\n\nstruct RacerList : View {\n    \n\t  // Mock data structure\n    let racers: [[String:String]] = [\n        [\n            \"name\": \"Valentino Rossi\",\n            \"team\": \"Yamaha\"\n        ],\n        [\n            \"name\": \"Marc Márquez\",\n\t\t\t      \"team\": \"Repsol Honda\"\n        ]\n    ]\n    \n    var body: some View {\n        List(racers) { racer in\n            if let name: String = racer.name, team: String = racer.team {\n                Text(\"\\(name) rides with \\(team)\")\n            }\n        }\n    }\n}\n```\n\nThe compiler throws this error: `Unable to infer complex closure return type; add explicit type to disambiguate` , essentially boiling down to: \"Hey, I don't understand what type you're returning.\" But didn't we say the `name` and `team`  optionals are strings when we unwrapped them? \n\nAs it turns out, the problem isn't with the SwiftUI view code, it's with the data structure. __Swift is a strongly typed, protocol-oriented language__ (bold for my own sake). The data you pass into a `List` needs to conform to the `Identifiable` protocol so that it knows how to reference each item.\n\n> I like to think about protocols like this: protocols are to class inheritance as GraphQL is to REST. No really, hear me out! In regular class inheritance in most object-oriented languages, if you want to extend a class, you get all the methods and properties and other stuff from that class in your new sub-class. With protocols, you split up that baggage into different \"slices\" that you can tell your new classes to conform to. Much like GraphQL, where you tell the backend exactly what you want and what you don't want, protocols allow you to define exactly what you want your sub classes (or structs) to get.\n\nWe can implement the `Identifiable` protocol like this:\n\n```swift\nimport SwiftUI\n\n// Mock data structure\nstruct Racer: Identifiable {\n    var id: Int\n    var name: String\n    var team: String\n}\n\nstruct RacerList : View {\n    var body: some View {\n        let a = Racer(id: 1, name: \"Valentino Rossi\", team: \"Yamaha\")\n        let b = Racer(id: 2, name: \"Marc Márquez\", team: \"Repsol Honda\")\n        let racers = [a, b]\n        \n        return List(racers) { racer in\n            Text(\"\\(racer.name) rides with \\(racer.team)\")\n        }\n    }\n}\n```\n\nYay, it works! 🙌 Now if we're to start refactoring this a bit, we can take the data structure, or *model* as it's known in the iOS world, and put it in a separate directory with all our models. Then, anywhere in our app we define a capital R `Racer`, the compiler knows we are referencing our model, and hence has detailed information about how it conforms to `Identifiable` and the type of each property.\n\nDone! This has been another round trip in what may become a loosely associated series of articles about how to do things in Swift coming from JavaScript land. Cheers!\n\nMore resources:\n* [SwiftUI List Tutorial by Apple](https://developer.apple.com/tutorials/swiftui/building-lists-and-navigation)\n* [Protocols — The Swift Programming Language (Swift 5.1)](https://docs.swift.org/swift-book/LanguageGuide/Protocols.html)\n* [Identifiable - SwiftUI | Apple Developer Documentation](https://developer.apple.com/documentation/swiftui/identifiable)\n* [Different flavors of view models in Swift — Swift by Sundell](https://www.swiftbysundell.com/posts/different-flavors-of-view-models-in-swift)\n"}},{"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"4jgiilbaovvs"}},"id":"color-extensions-swift","type":"Entry","createdAt":"2019-12-15T16:06:14.869Z","updatedAt":"2019-12-15T16:06:14.869Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment"}},"revision":1,"contentType":{"sys":{"type":"Link","linkType":"ContentType","id":"blogPost"}},"locale":"en-US"},"fields":{"title":"JS to Swift - Color management","slug":"color-extensions-swift","date":"2019-05-12","shortDescription":"Trying to create simple utility color variables in Swift led me on a journey of boilerplate and gotchas. But in the end, success!","category":["Swift"],"body":"\nA full-time developer on the web and part-time dabbler in the world of iOS development, I recently tried to create some color variables to use throughout a project in a single location. In most web development projects, you might put these inside a `utils` folder and `import` them wherever they are needed:\n\nDefine color variable:\n```javascript\n// utils/colors.js\n\nexport const dark = '#151951' // Default for all text\n```\n\nUse the variable:\n```javascript\n// components/container.js\n\nimport { dark } from '../utils/colors'\n\nconst Container = () => {\n\treturn <p style=`color: ${dark}`></p> \n}\n\nexport default Container\n```\n\nBut in iOS development with Swift, there’s a problem with this. Unlike on the web, you don’t explicitly declare what you are importing and exporting in each file. Instead, methods of classes just magically become available throughout the project. While convenient, how will others reading your code know where the methods are coming from?\n\nWe could [use a Swift protocol](https://medium.com/@KaushElsewhere/better-way-to-manage-swift-extensions-in-ios-project-78dc34221bc8) and namespace all the utils in the same class, or do something a bit simpler which I prefer: prepend an `_` before all extensions so we know they’re custom utility functions. The same example above would then look like this, using [extensions in Swift](https://docs.swift.org/swift-book/LanguageGuide/Extensions.html):\n\n> The usage of hex values for colors in iOS development requires some extra computation with  `UIColor`  because Apple doesn’t accept hex values directly. See dozens of different implementations of this [on StackOverflow](https://stackoverflow.com/questions/24263007/how-to-use-hex-color-values). The following approach is borrowed from [Jared Davidson](https://www.youtube.com/watch?v=HPhqO0D1tG4), and the emoji logging idea from [Andyy Hope’s Pretty in Print series](https://medium.com/swift-programming/swift-prettify-your-print-statements-pt-1-64832bb7fafa).\n\nDefine color variable:\n```swift\n//  Colors.swift\n\nimport UIKit\n\nextension UIColor {\n  \n\t// Defined colors\n  static let _dark = UIColor().hex(\"#151951\")\n  \n  func hex(_ hex: String) -> UIColor {\n    \n    // Clean string\n    var hexString = hex.trimmingCharacters(in: .whitespacesAndNewlines).uppercased()\n    \n    // Remove hash\n    if hexString.hasPrefix(\"#\") {\n      hexString.remove(at: hexString.startIndex)\n    }\n    \n    // Log warning if hex value is not 6 characters\n    if hexString.count != 6 {\n      print(\"⚠️ Hex value #\\(hexString) is not 6 characters.\n      Please enter a value with 6 characters.\")\n      return UIColor.white\n    }\n    \n    var rgb: UInt32 = 0\n    Scanner(string: hexString).scanHexInt32(&rgb)\n    \n    return UIColor.init(\n      red: CGFloat((rgb & 0xFF0000) >> 16) / 255.0,\n      green: CGFloat((rgb & 0x00FF00) >> 8) / 255.0,\n      blue: CGFloat(rgb & 0x0000FF) / 255.0,\n      alpha: 1.0\n    )\n  }\n}\n```\n\nUse the color variable:\n```swift\n// CustomLabel.swift\n\nimport UIKit\n\nclass CustomLabel: UILabel {\n  required init?(coder aDecoder: NSCoder) {\n    super.init(coder: aDecoder)\n    self.textColor = UIColor._dark\n  }\n}\n```\n\nAs I’m rapidly realizing, things you can do simply on the web with JavaScript don’t often come for free in iOS with Swift. This may be due to the relative newness of the language, particular design choices made by the architects, or a mix of both. \n\nWhile I know it’s not exactly helpful to apply web thinking to a native iOS context, I find it useful to compare and contrast implementations as I’m learning to write more idiomatic Swift. Hopefully, I’ll come out a better software developer at the end of the day.\n\nCheers! 🍻\n"}},{"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"4jgiilbaovvs"}},"id":"internet-hoarders","type":"Entry","createdAt":"2019-12-15T16:06:01.672Z","updatedAt":"2019-12-15T16:06:01.672Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment"}},"revision":1,"contentType":{"sys":{"type":"Link","linkType":"ContentType","id":"blogPost"}},"locale":"en-US"},"fields":{"title":"We’re all hoarders on the internet","slug":"internet-hoarders","date":"2019-05-09","shortDescription":"Everything I now own fits in just two large pieces of luggage. But on the internet, this is so much more difficult to do.","category":["Misc"],"body":"\nOver the past few years I’ve moved around a lot, living in Los Angeles, Seoul, Beijing and now Singapore. Over the course of these moves I pared down my belongings, so now everything fits in just two large pieces of luggage.\n\nBut on the internet, this is so much more difficult to do. Most of us have more than a few suitcases worth of accounts and user data floating around out there. More so, even if we want to toss out some of these things, we usually can’t do it quickly or easily. For each account,\n\n* Log in (~30 seconds)\n* Reset password? (~1-2 minutes)\n* Export user data? (~1-2 minutes)\n* Delete account (~1-2 minutes)\n\nThat’s 5 minutes per account. Now multiply that by all your accounts, of which I have, maybe 20 or 25. Now imagine you get stuck in a loop trying to reset a password or retrieve an old email address in a janky auth flow (Microsoft, looking at you).\n\n🤯 If only we could just  `rm -rf accounts`\n\nBut the saga continues. Besides closing down old accounts, what about changing all your passwords to unique, secure ones and storing them in a password manager? I’ve been down that road already. Estimate many more days or weeks.\n\nThe point is, It’s really hard to have just two suitcases worth of internet stuff because it lives in so many guarded places. I’m a fan of new projects emerging from this line of thinking like [Solid](https://solid.mit.edu), but it may be some time before every user is savvy enough to have something like their own personal “pod” or cloud.\n\nThat being said, I’ve been thinking about a few actionable targets we can observe as developers that can keep new apps from adding to this unwelcome trend:\n\n* Do not require authentication, or if absolutely necessary, require only an email address.\n* Store data locally or in a cloud already owned by the users.\n* If data is stored remotely, make user data export and deletion as readily accessible as possible.\n\nI plan on implementing these ideas in the side project I’m working on now. As for the rest of the apps out there that we depend on daily, the only way is to painstakingly reduce our dependency until cleaner alternatives are built.\n"}},{"sys":{"space":{"sys":{"type":"Link","linkType":"Space","id":"4jgiilbaovvs"}},"id":"styled-components-media-queries","type":"Entry","createdAt":"2019-12-15T16:02:34.416Z","updatedAt":"2019-12-15T16:02:34.416Z","environment":{"sys":{"id":"master","type":"Link","linkType":"Environment"}},"revision":1,"contentType":{"sys":{"type":"Link","linkType":"ContentType","id":"blogPost"}},"locale":"en-US"},"fields":{"title":"Media query templates in styled components","slug":"styled-components-media-queries","date":"2018-12-03","shortDescription":"A very neat approach to applying media queries across all your styled components in a project.","category":["CSS","JavaScript"],"body":"\nOf late, the ‘CSS in JS’ approach to organizing stylesheets in a project has become ever more popular in the JavaScript ecosystem. I think there are two main reasons for this:\n\n* In a world where everything is a component, coupling styles with view code makes each component more manageable and sharable between projects.\n* The ability to use __variables__, especially by interpolating them with JavaScript template literals, allows for an even greater amount of flexibility than what you get using a CSS preprocessor like SASS or LESS.\n\nThat being said, most people seem to favor one of two approaches to implementing CSS in JS: [styled-components](https://www.styled-components.com/), and [emotion](https://emotion.sh/). Both are similar in many respects, but most of my experience has been with the larger of the two projects, styled components.\n\nIn this post, I’ll touch on what I think is one of the neatest parts of how styled components can be used: [media templates](https://www.styled-components.com/docs/advanced#media-templates)! Here's what the styled components docs have to say about it:\n\n> Since media queries are long and are often repeated throughout an application, it can be useful to create a template for them. Due to the functional nature of JavaScript, you can easily define your own tagged template literal to wrap styles in media queries.\n\nLet me show you how I’m using this approach in this site:\n\n```javascript\n// media.js\nimport { css } from 'styled-components'\n\nconst sizes = {\n\t// Default styles written mobile-first assuming 320px width\n\tmbl: 375,\n\ttab: 700,\n\tdesk: 990,\n\tdeskL: 1200,\n}\n\n// Iterate through the sizes and create a media template\nconst media = Object.keys(sizes).reduce((acc, label) => {\n\tacc[label] = (...args) => css`\n\t\t@media (min-width: ${sizes[label] / 16}em) {\n\t\t\t${css(...args)};\n\t\t}\n\t`\n\n\treturn acc\n}, {})\n\nexport default media\n```\n\nI tuck the above code away in the `utils` directory, and then whenever I need to use a media query in any component throughout the project I can import and use it like so:\n\n```javascript\n// textXL.js\nimport styled from 'styled-components'\nimport { dark } from '../utils/colors'\nimport media from '../utils/media'\n\nconst TextXL = styled.h1`\n\tfont-family: Quincy, serif;\n\tfont-weight: normal;\n\tfont-size: 44px;\n\tcolor: ${dark};\n\tline-height: 52px;\n\tpadding: ${props => (props.padding ? props.padding : `auto`)};\n\tmargin: ${props => (props.margin ? props.margin : `auto`)};\n\ttext-align: ${props => (props.center ? `center` : `left`)};\n\t${media.tab`\n\t\tfont-size: 48px;\n\t\tline-height: 58px;\n\t`};\n`\n\nexport default TextXL\n```\n\nAnd that’s it! There are many more exciting aspects of how to extend styled components, but of all of them, this solution to media queries is by far the most elegant and unique in my view. Hope you enjoy using this as much as I do, and happy querying!\n"}}]